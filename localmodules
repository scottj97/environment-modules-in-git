#%Module1.0######################################################################
##
## When loaded, use a local git repo for our Modulefiles,
## instead of the system-wide location that is typically used.
##
## This is useful for editing and testing Modulefiles.
##
## Tune to your system:
## 1. $localmoddir and $globalmoddir
## 2. ?

eval set  [ array get env HOME ]
set localmoddir   $HOME/modulefiles
set globalmoddir /home/modules/modulefiles


proc ModulesHelp { } {
    puts stderr "localmodules: switch to local Git repo for Modulefiles\n"
    puts stderr "This is useful for editing and testing Modulefiles."
    puts stderr "Usage:"
    puts stderr "   $ module load localmodules"
    puts stderr "Then edit and test modulefiles in ~/modulefiles"
    puts stderr "When complete, git commit and push, then"
    puts stderr "   $ module unload localmodules"
}

module-whatis   "switch MODULEPATH to local git repo"

# create directory if necessary
if [ module-info mode load ] {
    if { ! [ file exists $localmoddir ] } {
        error "TBD -- create $localmoddir"
    }
}

## These two work for load, but not for unload (the $globalmoddir doesn't get put back in):
##   remove-path MODULEPATH $globalmoddir
##   append-path MODULEPATH $localmoddir

## These two work for load, but not for unload (the $globalmoddir doesn't get put back in):
module unuse $globalmoddir
module use --append $localmoddir

if [ module-info mode unload ] {
    ## The `module unuse` does not get automatically undone during `unload`.
    ## So we have to manually reverse it.

    ## Ugly hack: this works, but assumes that $globalmoddir should be the only MODULEPATH
    unsetenv MODULEPATH $globalmoddir
    unsetenv MODULEPATH_modshare $globalmoddir:1
}

if [ module-info mode load ] {
    puts stderr "Switched to local modulefiles in ~/modulefiles"
    puts stderr "When editing and testing complete, git commit and push, then:"
    puts stderr "   $ module unload localmodules"
}
