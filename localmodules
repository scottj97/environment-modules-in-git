#%Module1.0######################################################################
##
## When loaded, use a local git repo for our Modulefiles,
## instead of the system-wide location that is typically used.
##
## This is useful for editing and testing Modulefiles.
##
## Tune to your system:
## $localmoddir, $globalmod_fetch, $globalmod_push
##
## github.com/scottj97/environment-modules-in-git


eval set  [ array get env HOME ]

# Where each user's local copy should go:
set localmoddir   $HOME/modulefiles

# Where `git fetch` can find the master repo:
set globalmod_fetch /home/modules/modulefiles

# Where `git push` should write to the master repo:
set globalmod_push ssh://modules@localhost/home/modules/modulefiles



proc ModulesHelp { } {
    upvar #0 localmoddir localmoddir
    puts stderr "localmodules: switch to local Git repo for Modulefiles\n"
    puts stderr "This is useful for editing and testing Modulefiles."
    puts stderr "Usage:"
    puts stderr "   $ module load localmodules"
    puts stderr "Then edit and test modulefiles in $localmoddir"
    puts stderr "When complete, git commit and push, then"
    puts stderr "   $ module unload localmodules"
}

module-whatis   "switch MODULEPATH to local git repo"

# Runs `system` and dies if error code is nonzero
proc safesystem {cmd} {
    set retcode [ system $cmd ]
    if { [ expr { $retcode != 0 } ] } {
        error "`$cmd` returned non-zero exit code: $retcode"
    }
}

# Make sure $localmoddir is what we expect, so we don't clobber anybody's work
# if they happen to have something unexpected here
proc ensure-proper-localmoddir {} {
    upvar #0 localmoddir dir
    upvar #0 globalmod_fetch globalmod_fetch
    upvar #0 globalmod_push globalmod_push

    # Make sure it's a directory
    if { ! [ file isdirectory $dir ] } {
        error "a file named $dir already exists, and I don't want to clobber it"
    }

    # Make sure it has the expected .git remote setup
    if { ! [ file isdirectory [ file join $dir ".git" ] ] } {
        error "expected git repo inside $dir, found none"
    }
    safesystem "if \[ `git -C $dir remote get-url origin` != \"$globalmod_fetch\" ]; then exit 1; fi"
    safesystem "if \[ `git -C $dir remote get-url --push origin` != \"$globalmod_push\" ]; then exit 1; fi"
}

# No $localmoddir exists, so run `git clone` to create
proc create-localmoddir {} {
    upvar #0 localmoddir localmoddir
    upvar #0 globalmod_fetch globalmod_fetch
    upvar #0 globalmod_push globalmod_push

    safesystem "git clone $globalmod_fetch $localmoddir"
    safesystem "git -C $localmoddir remote set-url --push origin $globalmod_push"
}

proc check-repo-status {} {
    upvar #0 localmoddir localmoddir
    safesystem "git -C $localmoddir remote update"
    safesystem "git -C $localmoddir status"
}


# create directory if necessary
if [ module-info mode load ] {
    if { ! [ file exists $localmoddir ] } {
        create-localmoddir
    }
    ensure-proper-localmoddir
}

## These two work for load, but not for unload (the $globalmod_fetch doesn't get put back in):
##   remove-path MODULEPATH $globalmod_fetch
##   append-path MODULEPATH $localmoddir

## These two work for load, but not for unload (the $globalmod_fetch doesn't get put back in):
module unuse $globalmod_fetch
module use --append $localmoddir

if [ module-info mode unload ] {
    ## The `module unuse` does not get automatically undone during `unload`.
    ## So we have to manually reverse it.

    ## Ugly hack: this works, but assumes that $globalmod_fetch should be the only MODULEPATH
    unsetenv MODULEPATH $globalmod_fetch
    unsetenv MODULEPATH_modshare $globalmod_fetch:1
}

if [ module-info mode load ] {
    puts stderr "\nSwitched to local modulefiles in $localmoddir"
    puts stderr "When editing and testing complete, git commit and push, then:"
    puts stderr "   $ module unload localmodules\n"
    check-repo-status
}
