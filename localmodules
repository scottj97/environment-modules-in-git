#%Module1.0######################################################################
##
## When loaded, use a local git repo for our Modulefiles,
## instead of the system-wide location that is typically used.
##
## This is useful for editing and testing Modulefiles.
##
## Tune to your system:
## 1. $localmoddir, $globalmoddir, $globalmodssh
## 2. ?

eval set  [ array get env HOME ]

set localmoddir   $HOME/modulefiles
set globalmoddir /home/modules/modulefiles
# Equivalent path via git-ssh:
set globalmodssh ssh://modules@localhost/home/modules/modulefiles

proc ModulesHelp { } {
    upvar #0 localmoddir localmoddir
    puts stderr "localmodules: switch to local Git repo for Modulefiles\n"
    puts stderr "This is useful for editing and testing Modulefiles."
    puts stderr "Usage:"
    puts stderr "   $ module load localmodules"
    puts stderr "Then edit and test modulefiles in $localmoddir"
    puts stderr "When complete, git commit and push, then"
    puts stderr "   $ module unload localmodules"
}

module-whatis   "switch MODULEPATH to local git repo"

# Runs `system` and dies if error code is nonzero
proc safesystem {cmd} {
    set retcode [ system $cmd ]
    if { [ expr { $retcode != 0 } ] } {
        error "`$cmd` returned non-zero exit code: $retcode"
    }
}

# Make sure $localmoddir is what we expect, so we don't clobber anybody's work
# if they happen to have something unexpected here
proc ensure-proper-localmoddir {} {
    upvar #0 localmoddir dir
    upvar #0 globalmoddir globalmoddir
    upvar #0 globalmodssh globalmodssh

    # Make sure it's a directory
    if { ! [ file isdirectory $dir ] } {
        error "a file named $dir already exists, and I don't want to clobber it"
    }

    # Make sure it has the expected .git remote setup
    if { ! [ file isdirectory [ file join $dir ".git" ] ] } {
        error "expected git repo inside $dir, found none"
    }
    safesystem "if \[ `git -C $dir remote get-url origin` != \"$globalmoddir\" ]; then exit 1; fi"
    safesystem "if \[ `git -C $dir remote get-url --push origin` != \"$globalmodssh\" ]; then exit 1; fi"

    # Make sure it's up to date (`git pull --ff-only`)
    system "git -C $dir pull --ff-only"
}

# No $localmoddir exists, so run `git clone` to create
proc create-localmoddir {} {
    upvar #0 localmoddir localmoddir
    upvar #0 globalmoddir globalmoddir
    upvar #0 globalmodssh globalmodssh

    safesystem "git clone $globalmoddir $localmoddir"
    safesystem "git -C $localmoddir remote set-url --push origin $globalmodssh"
}


# create directory if necessary
if [ module-info mode load ] {
    if { ! [ file exists $localmoddir ] } {
        create-localmoddir
    }
    ensure-proper-localmoddir
}

## These two work for load, but not for unload (the $globalmoddir doesn't get put back in):
##   remove-path MODULEPATH $globalmoddir
##   append-path MODULEPATH $localmoddir

## These two work for load, but not for unload (the $globalmoddir doesn't get put back in):
module unuse $globalmoddir
module use --append $localmoddir

if [ module-info mode unload ] {
    ## The `module unuse` does not get automatically undone during `unload`.
    ## So we have to manually reverse it.

    ## Ugly hack: this works, but assumes that $globalmoddir should be the only MODULEPATH
    unsetenv MODULEPATH $globalmoddir
    unsetenv MODULEPATH_modshare $globalmoddir:1
}

if [ module-info mode load ] {
    puts stderr "Switched to local modulefiles in $localmoddir"
    puts stderr "When editing and testing complete, git commit and push, then:"
    puts stderr "   $ module unload localmodules"
}
